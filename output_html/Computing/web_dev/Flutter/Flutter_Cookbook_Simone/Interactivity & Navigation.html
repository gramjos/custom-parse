<!DOCTYPE html>
<html>
<head>
    <title>Interactivity & Navigation</title>
    <style>
        body {
    font-family: sans-serif;
    max-width: 800px;
    margin: 2rem auto;
    padding: 0 1rem;
}

h1, h2, h3 {
    color: #333;
}

p {
    line-height: 1.6;
}

pre {
    background: #f4f4f4;
    padding: 1em;
    border-radius: 5px;
    overflow-x: auto;
}

code {
    font-family: monospace;
    background: #f4f4f4;
    padding: 0.2em 0.4em;
    border-radius: 3px;
}

pre code {
    background: none;
    padding: 0;
}
    </style>
</head>
<body>
    <p><em>User Interface</em> is all the elements on the screen (images, colors, panels, text, etc) and the <em>User Experience</em> is what happens when the user's interact with the interface. "UI is the what and UX is the how" A stateful widget is divided into two classes: the widget and its state. Every stateful widget has a state object to help manage its life cycle (a completely separate class). As a design point, <code>StatefulWidgets</code> are of the few scenarios where two classes (the widget and the widget's state) should be in the same file. In <code>StatefulWidgets</code>, you put the <code>build</code> method in the <code>State</code> class, not in the widget  !<a href="setState.png">center</a> Remember, <code>StatefulWidgets</code> are made up of two classes: <strong>the widget</strong> and <strong>its state</strong>. The widget part of the <code>StatefulWidget</code> does not usually do much because the data that changes is placed in the <code>State</code> class. <em>*All widgets are immutable</em>*, but the <code>State</code> object is mutable. The <code>State</code> object is responsible for the <code>build</code> method. <em>Jargon</em>, "dirty state" means the in the next frame it will repaint. The <code>setState</code> function tells Flutter that a widget needs to be repainted. Every time <code>setState</code> is called the <code>build</code> method is called. Never call <code>build</code> directly, rather do it through <code>setState</code>. The following diagram summarizes how Flutter's render loop is impacted by <code>setState</code> !<a href="render_loop.png">center</a> <strong>Note</strong>, that complex operations should not be performed in the <code>setState</code> function, but just the final value assignment.</p><h4><code>State</code> Life Cycle</h4><p>Unlike <code>StatelessWidget</code>,  which has nothing more than a <code>build</code> method. <code>StatefulWidgets</code> have a life cycle of methods that are called in a specific order: - <code>initState</code> - <code>didChangeDependencies</code> - <code>didUpdateWidget</code> - <code>build</code> <em>*(required)</em>* - <code>reassemble</code> - <code>deactivate</code> - <code>dispose</code></p><p>> [!flut]- <code>initState</code> > - used to initialize any non-final state in the class > - <em>kinda like a constructor</em> > - This method is called <strong>after</strong> the constructor but <strong>before</strong> it is added to the widget tree.</p><p>> [!flut]- <code>didChangeDependencies</code> > - this method is called after <code>initState</code>, but has access to the <code>BuildContext</code> > - Useful for any set up work that requires <code>context</code></p><p>> [!flut]- <code>build</code> > - <strong>required</strong> > - Identical to the <code>StatelessWidget</code> version > - This defines and returns the widget's tree (creating the UI)</p><p>> [!flut]- <code>dispose</code> > - The cleanup method > - Called when the <code>State</code> object is removed from the widget tree > - One must explicitly release finished resources</p><h4>Buttons</h4><p>Flutter has several aesthetically different buttons - <code>ElevatedButton</code> - <code>TextButton</code> - <code>IconButton</code> - <code>FloatingActionButton</code> - <code>OutlinedButton</code> - <code>DropDownButton</code> - <code>CupertinoButton</code></p><h4>Scrolling</h4><p><code>ListView</code> has scrolling builtin by default when its widgets extend past the screen.  A scrolling widget needs to know their parent’s constraints to activate scrolling, putting scroll widgets inside widgets with unbounded constraints can cause Flutter to throw errors.</p><h5>Constraints go down -> Sizes go up</h5><p>More in <a href="Layout">Layout</a>  In Flutter there’s a rule: “Constraints go down. Sizes go up.”. This means that: - Parent widgets pass down constraints to their children. Constraints are passed in a <code>BoxContraints</code> object, that includes minimum and maximum values for the width and height of the children. - Children widgets determine their size and then pass the information back up to the parent widget If you place a scrolling widget inside a <code>Flex</code> widget (like <code>Row</code> or <code>Column</code>), which is pretty common, just don’t forget to always wrap the scrolling content in <code>Expanded</code> or <code>Flexible</code> first. This error means that you have an unbounded scrolling widget !<a href="unbounded_scroll_error.png">unbounded_scroll_error.png</a></p><h3>Handling Large Datasets with <code>ListView</code> (Scrolling)</h3><p>The problem is handling large amount of data in a scrolling widget. We know only a certain amounts of views (widgets that hold data) fit on any screen at once. The trick is to, recycling views with new data instead of creating new views. The <code>itemCount</code> property to the <code>ListView.builder()</code> lets Flutter know how long the list is. duh! The <code>itemBuilder</code> property and its value (a closure) help with performance to limit the creation of <code>Elements</code> and <code>RenderObjects</code>. <code>itemBuilder</code> is using <em>deferred rendering</em> to create only what it needs and manage a subset of the total widgets. The <em>scroll tree</em> is limited to only what is needed.  Flutter will continuously call <code>itemBuilder</code> with an updated index as the user scrolls. Assuming the size of the viewport is constant, the programmer only manages the fixed number of visible entries.  !<a href="scrollViewPort.png">scrollViewPort.png</a>  <code>itemExtent</code> property is a way to supply a fixed height to all the items in <code>ListView</code>. Instead of letting the widget figure out its own height based on the content, using <code>itemExtent</code> will enforce a fixed height and leads to performance benefits.   <code>ScrollController</code> object allows programmers to interact with a <code>ListView</code> from outside the build methods.</p><pre><code class="language-dart">scrollController.animateTo(
  itemHeight * laps.length,
  duration: Duration(milliseconds: 500),
  curve: Curves.easeIn,
);</code></pre><p><code>itemHeight * laps.length,</code> this argument dictates where to scroll to.  Since, there we set items to have a fixed height we can calculate how far to automatically scroll.</p><p><code>duration: Duration(milliseconds: 500),</code> dictates how long it will take to scroll to the calculated position.</p><p><code>curve: Curves.easeIn,</code> how (animate) to get there</p><h3>Working with <code>TextField</code>s</h3><p><code>TextField</code> has a subclass called <code>TextFormField</code> for text fields that interact with each other. <code>TextField</code>s are platform aware widgets. <code>validator</code> on failure will return a string and on success return <code>null</code>. <code>Form</code> widget can wrap many <code>TextFields</code> and is a non-rendering widget. <code>Form</code> can contain non-<code>TextFields</code>, but keeps track which ones <code>null</code>(valid). If all validator functions wrapped in <code>Form</code> return <code>null</code> then the entire <code>Form</code> is valid.  <code>GlobalKey</code> used to get access to the form’s state class from outside the <code>build</code> method. <code>GlobalKey</code>'s uniquely identify elements. While <code>BuildContext</code> is an object that can find <em>*parents</em><em>  in the widget tree, `GlobalKey`'s are objects that you use to retrieve a </em><em>child</em>* widget tree. (<em>GlobalKey is a complex topic. This is a brief, crude intro</em>). In short, with the key, you can retrieve the Form’s state. The <code>FormState</code> class has a public method called <code>validate</code> that will call the validator on all its children.</p><h3>Navigating to the next screen</h3><p><em>*Now working from stopwatch part 2 project</em>* Within <code>MaterialApp</code> a class called <code>Navigator</code> manages screens. The <code>Navigator</code> class abstracts screens to the concept of <code>Routes</code>.  Regarding a login event, once a use logs successfully the back button to return to the login screen should be inaccessible.</p><pre><code class="language-dart">Navigator.of(context).pushReplacement( 
	MaterialPageRoute( 
		builder: (_) => 
			StopWatch(name: name, email: email), ), );</code></pre><p><code>Navigator</code>'s function as a stack. <code>Routes</code> can be pushed onto and popped off of.The above snippet will remove the <code>Route</code> (screen) from the <code>Navigator</code> stack. <code>pushNamed</code> does pop then push of the current stack</p><h3>Presenting Bottom Sheet</h3><p><em>*Now working from stopwatch part 3 project</em><em> A bottom sheet is like a footer that be animated. It can temporarily or permanently appear after an event.   The app's widget looks like. ![[widgetTree.png]] Bottom sheets are partial routes. They use the closest `Scaffold` by using the `of-context` to find it. The above graphic shows the `BuildContext` we do </em><em>not</em>* want. The error message <code>No Scaffold Widget found</code> will be triggered when the nearest <code>Scaffold</code> is too far up in the tree to be used. The solution is to use a <code>BuildContext</code> lower in the tree. Wrapping the button (that uses the bottom sheet) in the <code>Builder</code> widget will solve this.  !<a href="bottomSheetBuilder.png">bottomSheetBuilder.png</a> The above snippet demonstrate how to create a <code>BuildContext</code> closer to the button.  !<a href="widgetTreeWithBuilder.png">widgetTreeWithBuilder.png</a></p><h6>Persistent controllers</h6><p>!<a href="bottomSheetController.png">bottomSheetController.png</a> The <code>showBottomSheet</code> method returns a <em>*persistent controller</em>* used to manipulate them.</p>
</body>
</html>